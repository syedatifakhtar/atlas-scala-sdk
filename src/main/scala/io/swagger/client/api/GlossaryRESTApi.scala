/**
 * Atlas REST API
 * Atlas exposes a variety of REST endpoints to work with types, entities, lineage and data discovery.
 *
 * OpenAPI spec version: 2.0.0-SNAPSHOT
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api

import java.text.SimpleDateFormat

import io.swagger.client.model.JsonAtlasGlossary
import io.swagger.client.model.JsonAtlasGlossaryCategory
import io.swagger.client.model.JsonAtlasGlossaryExtInfo
import io.swagger.client.model.JsonAtlasGlossaryTerm
import io.swagger.client.model.JsonAtlasRelatedCategoryHeader
import io.swagger.client.model.JsonAtlasRelatedObjectId
import io.swagger.client.model.JsonAtlasRelatedTermHeader
import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date
import java.util.TimeZone

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

import org.json4s._

class GlossaryRESTApi(
  val defBasePath: String = "https://localhost:21000",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new GlossaryRESTApiAsyncHelper(client, config)

  /**
   * Assign the given term to the provided list of entity headers.
   * Assign the given term to the provided list of entity headers
   *
   * @param termGuid Glossary term GUID 
   * @param body Related Entity IDs to which the term has to be associated (optional)
   * @return void
   */
  def assignTermToEntities(termGuid: String, body: Option[List[JsonAtlasRelatedObjectId]] = None) = {
    val await = Try(Await.result(assignTermToEntitiesAsync(termGuid, body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Assign the given term to the provided list of entity headers. asynchronously
   * Assign the given term to the provided list of entity headers
   *
   * @param termGuid Glossary term GUID 
   * @param body Related Entity IDs to which the term has to be associated (optional)
   * @return Future(void)
   */
  def assignTermToEntitiesAsync(termGuid: String, body: Option[List[JsonAtlasRelatedObjectId]] = None) = {
      helper.assignTermToEntities(termGuid, body)
  }

  /**
   * Create a glossary.
   * Create a glossary
   *
   * @param body Glossary definition, terms &amp; categories can be anchored to a glossary using the anchor attribute when creating the Term/Category (optional)
   * @return JsonAtlasGlossary
   */
  def createGlossary(body: Option[JsonAtlasGlossary] = None): Option[JsonAtlasGlossary] = {
    val await = Try(Await.result(createGlossaryAsync(body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create a glossary. asynchronously
   * Create a glossary
   *
   * @param body Glossary definition, terms &amp; categories can be anchored to a glossary using the anchor attribute when creating the Term/Category (optional)
   * @return Future(JsonAtlasGlossary)
   */
  def createGlossaryAsync(body: Option[JsonAtlasGlossary] = None): Future[JsonAtlasGlossary] = {
      helper.createGlossary(body)
  }

  /**
   * Create glossary category in bulk.
   * Create glossary category in bulk
   *
   * @param body glossary category definitions (optional)
   * @return List[JsonAtlasGlossaryCategory]
   */
  def createGlossaryCategories(body: Option[List[JsonAtlasGlossaryCategory]] = None): Option[List[JsonAtlasGlossaryCategory]] = {
    val await = Try(Await.result(createGlossaryCategoriesAsync(body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create glossary category in bulk. asynchronously
   * Create glossary category in bulk
   *
   * @param body glossary category definitions (optional)
   * @return Future(List[JsonAtlasGlossaryCategory])
   */
  def createGlossaryCategoriesAsync(body: Option[List[JsonAtlasGlossaryCategory]] = None): Future[List[JsonAtlasGlossaryCategory]] = {
      helper.createGlossaryCategories(body)
  }

  /**
   * Create glossary category.
   * Create glossary category
   *
   * @param body glossary category definition, a category must be anchored to a Glossary when creating Optionally, terms belonging to the category and the hierarchy can also be defined during creation (optional)
   * @return JsonAtlasGlossaryCategory
   */
  def createGlossaryCategory(body: Option[JsonAtlasGlossaryCategory] = None): Option[JsonAtlasGlossaryCategory] = {
    val await = Try(Await.result(createGlossaryCategoryAsync(body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create glossary category. asynchronously
   * Create glossary category
   *
   * @param body glossary category definition, a category must be anchored to a Glossary when creating Optionally, terms belonging to the category and the hierarchy can also be defined during creation (optional)
   * @return Future(JsonAtlasGlossaryCategory)
   */
  def createGlossaryCategoryAsync(body: Option[JsonAtlasGlossaryCategory] = None): Future[JsonAtlasGlossaryCategory] = {
      helper.createGlossaryCategory(body)
  }

  /**
   * Create a glossary term.
   * Create a glossary term
   *
   * @param body Glossary term definition, a term must be anchored to a Glossary at the time of creation optionally it can be categorized as well (optional)
   * @return JsonAtlasGlossaryTerm
   */
  def createGlossaryTerm(body: Option[JsonAtlasGlossaryTerm] = None): Option[JsonAtlasGlossaryTerm] = {
    val await = Try(Await.result(createGlossaryTermAsync(body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create a glossary term. asynchronously
   * Create a glossary term
   *
   * @param body Glossary term definition, a term must be anchored to a Glossary at the time of creation optionally it can be categorized as well (optional)
   * @return Future(JsonAtlasGlossaryTerm)
   */
  def createGlossaryTermAsync(body: Option[JsonAtlasGlossaryTerm] = None): Future[JsonAtlasGlossaryTerm] = {
      helper.createGlossaryTerm(body)
  }

  /**
   * Create glossary terms in bulk.
   * Create glossary terms in bulk
   *
   * @param body glossary term definitions (optional)
   * @return List[JsonAtlasGlossaryTerm]
   */
  def createGlossaryTerms(body: Option[List[JsonAtlasGlossaryTerm]] = None): Option[List[JsonAtlasGlossaryTerm]] = {
    val await = Try(Await.result(createGlossaryTermsAsync(body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create glossary terms in bulk. asynchronously
   * Create glossary terms in bulk
   *
   * @param body glossary term definitions (optional)
   * @return Future(List[JsonAtlasGlossaryTerm])
   */
  def createGlossaryTermsAsync(body: Option[List[JsonAtlasGlossaryTerm]] = None): Future[List[JsonAtlasGlossaryTerm]] = {
      helper.createGlossaryTerms(body)
  }

  /**
   * Delete a glossary.
   * Delete a glossary
   *
   * @param glossaryGuid unique identifier for glossary 
   * @return void
   */
  def deleteGlossary(glossaryGuid: String) = {
    val await = Try(Await.result(deleteGlossaryAsync(glossaryGuid), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete a glossary. asynchronously
   * Delete a glossary
   *
   * @param glossaryGuid unique identifier for glossary 
   * @return Future(void)
   */
  def deleteGlossaryAsync(glossaryGuid: String) = {
      helper.deleteGlossary(glossaryGuid)
  }

  /**
   * Delete a glossary category.
   * Delete a glossary category
   *
   * @param categoryGuid unique identifier for glossary category 
   * @return void
   */
  def deleteGlossaryCategory(categoryGuid: String) = {
    val await = Try(Await.result(deleteGlossaryCategoryAsync(categoryGuid), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete a glossary category. asynchronously
   * Delete a glossary category
   *
   * @param categoryGuid unique identifier for glossary category 
   * @return Future(void)
   */
  def deleteGlossaryCategoryAsync(categoryGuid: String) = {
      helper.deleteGlossaryCategory(categoryGuid)
  }

  /**
   * Delete a glossary term.
   * Delete a glossary term
   *
   * @param termGuid unique identifier for glossary term 
   * @return void
   */
  def deleteGlossaryTerm(termGuid: String) = {
    val await = Try(Await.result(deleteGlossaryTermAsync(termGuid), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete a glossary term. asynchronously
   * Delete a glossary term
   *
   * @param termGuid unique identifier for glossary term 
   * @return Future(void)
   */
  def deleteGlossaryTermAsync(termGuid: String) = {
      helper.deleteGlossaryTerm(termGuid)
  }

  /**
   * Remove the term assignment for the given list of entity headers.
   * Remove the term assignment for the given list of entity headers
   *
   * @param termGuid Glossary term GUID 
   * @param body List of related entity IDs from which the term has to be dissociated (optional)
   * @return void
   */
  def disassociateTermAssignmentFromEntities(termGuid: String, body: Option[List[JsonAtlasRelatedObjectId]] = None) = {
    val await = Try(Await.result(disassociateTermAssignmentFromEntitiesAsync(termGuid, body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Remove the term assignment for the given list of entity headers. asynchronously
   * Remove the term assignment for the given list of entity headers
   *
   * @param termGuid Glossary term GUID 
   * @param body List of related entity IDs from which the term has to be dissociated (optional)
   * @return Future(void)
   */
  def disassociateTermAssignmentFromEntitiesAsync(termGuid: String, body: Option[List[JsonAtlasRelatedObjectId]] = None) = {
      helper.disassociateTermAssignmentFromEntities(termGuid, body)
  }

  /**
   * Get all terms associated with the specific category.
   * Get all terms associated with the specific category
   *
   * @param categoryGuid unique identifier for glossary category 
   * @param limit page size - by default there is no paging (optional, default to -1)
   * @param offset offset for pagination purpose (optional, default to 0)
   * @param sort ASC (default) or DESC (optional, default to ASC)
   * @return List[JsonAtlasRelatedTermHeader]
   */
  def getCategoryTerms(categoryGuid: String, limit: Option[String] = Option("-1"), offset: Option[String] = Option("0"), sort: Option[String] = Option("ASC")): Option[List[JsonAtlasRelatedTermHeader]] = {
    val await = Try(Await.result(getCategoryTermsAsync(categoryGuid, limit, offset, sort), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get all terms associated with the specific category. asynchronously
   * Get all terms associated with the specific category
   *
   * @param categoryGuid unique identifier for glossary category 
   * @param limit page size - by default there is no paging (optional, default to -1)
   * @param offset offset for pagination purpose (optional, default to 0)
   * @param sort ASC (default) or DESC (optional, default to ASC)
   * @return Future(List[JsonAtlasRelatedTermHeader])
   */
  def getCategoryTermsAsync(categoryGuid: String, limit: Option[String] = Option("-1"), offset: Option[String] = Option("0"), sort: Option[String] = Option("ASC")): Future[List[JsonAtlasRelatedTermHeader]] = {
      helper.getCategoryTerms(categoryGuid, limit, offset, sort)
  }

  /**
   * Get a specific Glossary.
   * Get a specific Glossary
   *
   * @param glossaryGuid unique glossary identifier 
   * @return JsonAtlasGlossaryExtInfo
   */
  def getDetailedGlossary(glossaryGuid: String): Option[JsonAtlasGlossaryExtInfo] = {
    val await = Try(Await.result(getDetailedGlossaryAsync(glossaryGuid), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get a specific Glossary. asynchronously
   * Get a specific Glossary
   *
   * @param glossaryGuid unique glossary identifier 
   * @return Future(JsonAtlasGlossaryExtInfo)
   */
  def getDetailedGlossaryAsync(glossaryGuid: String): Future[JsonAtlasGlossaryExtInfo] = {
      helper.getDetailedGlossary(glossaryGuid)
  }

  /**
   * Get all entity headers assigned with the specified term.
   * Get all entity headers assigned with the specified term
   *
   * @param termGuid GUID of the term 
   * @param limit page size - by default there is no paging (optional, default to -1)
   * @param offset offset for pagination purpose (optional, default to 0)
   * @param sort ASC (default) or DESC (optional, default to ASC)
   * @return List[JsonAtlasRelatedObjectId]
   */
  def getEntitiesAssignedWithTerm(termGuid: String, limit: Option[String] = Option("-1"), offset: Option[String] = Option("0"), sort: Option[String] = Option("ASC")): Option[List[JsonAtlasRelatedObjectId]] = {
    val await = Try(Await.result(getEntitiesAssignedWithTermAsync(termGuid, limit, offset, sort), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get all entity headers assigned with the specified term. asynchronously
   * Get all entity headers assigned with the specified term
   *
   * @param termGuid GUID of the term 
   * @param limit page size - by default there is no paging (optional, default to -1)
   * @param offset offset for pagination purpose (optional, default to 0)
   * @param sort ASC (default) or DESC (optional, default to ASC)
   * @return Future(List[JsonAtlasRelatedObjectId])
   */
  def getEntitiesAssignedWithTermAsync(termGuid: String, limit: Option[String] = Option("-1"), offset: Option[String] = Option("0"), sort: Option[String] = Option("ASC")): Future[List[JsonAtlasRelatedObjectId]] = {
      helper.getEntitiesAssignedWithTerm(termGuid, limit, offset, sort)
  }

  /**
   * Retrieve all glossaries registered with Atlas.
   * Retrieve all glossaries registered with Atlas
   *
   * @param limit page size - by default there is no paging (optional, default to -1)
   * @param offset offset for pagination purpose (optional, default to 0)
   * @param sort Sort order, ASC (default) or DESC (optional, default to ASC)
   * @return List[JsonAtlasGlossary]
   */
  def getGlossaries(limit: Option[String] = Option("-1"), offset: Option[String] = Option("0"), sort: Option[String] = Option("ASC")): Option[List[JsonAtlasGlossary]] = {
    val await = Try(Await.result(getGlossariesAsync(limit, offset, sort), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Retrieve all glossaries registered with Atlas. asynchronously
   * Retrieve all glossaries registered with Atlas
   *
   * @param limit page size - by default there is no paging (optional, default to -1)
   * @param offset offset for pagination purpose (optional, default to 0)
   * @param sort Sort order, ASC (default) or DESC (optional, default to ASC)
   * @return Future(List[JsonAtlasGlossary])
   */
  def getGlossariesAsync(limit: Option[String] = Option("-1"), offset: Option[String] = Option("0"), sort: Option[String] = Option("ASC")): Future[List[JsonAtlasGlossary]] = {
      helper.getGlossaries(limit, offset, sort)
  }

  /**
   * Get a specific Glossary.
   * Get a specific Glossary
   *
   * @param glossaryGuid unique glossary identifier 
   * @return JsonAtlasGlossary
   */
  def getGlossary(glossaryGuid: String): Option[JsonAtlasGlossary] = {
    val await = Try(Await.result(getGlossaryAsync(glossaryGuid), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get a specific Glossary. asynchronously
   * Get a specific Glossary
   *
   * @param glossaryGuid unique glossary identifier 
   * @return Future(JsonAtlasGlossary)
   */
  def getGlossaryAsync(glossaryGuid: String): Future[JsonAtlasGlossary] = {
      helper.getGlossary(glossaryGuid)
  }

  /**
   * Get the categories belonging to a specific glossary.
   * Get the categories belonging to a specific glossary
   *
   * @param glossaryGuid unique identifier for glossary term 
   * @param limit page size - by default there is no paging (optional, default to -1)
   * @param offset offset for pagination purpose (optional, default to 0)
   * @param sort ASC (default) or DESC (optional, default to ASC)
   * @return List[JsonAtlasGlossaryCategory]
   */
  def getGlossaryCategories(glossaryGuid: String, limit: Option[String] = Option("-1"), offset: Option[String] = Option("0"), sort: Option[String] = Option("ASC")): Option[List[JsonAtlasGlossaryCategory]] = {
    val await = Try(Await.result(getGlossaryCategoriesAsync(glossaryGuid, limit, offset, sort), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get the categories belonging to a specific glossary. asynchronously
   * Get the categories belonging to a specific glossary
   *
   * @param glossaryGuid unique identifier for glossary term 
   * @param limit page size - by default there is no paging (optional, default to -1)
   * @param offset offset for pagination purpose (optional, default to 0)
   * @param sort ASC (default) or DESC (optional, default to ASC)
   * @return Future(List[JsonAtlasGlossaryCategory])
   */
  def getGlossaryCategoriesAsync(glossaryGuid: String, limit: Option[String] = Option("-1"), offset: Option[String] = Option("0"), sort: Option[String] = Option("ASC")): Future[List[JsonAtlasGlossaryCategory]] = {
      helper.getGlossaryCategories(glossaryGuid, limit, offset, sort)
  }

  /**
   * Get the categories belonging to a specific glossary.
   * Get the categories belonging to a specific glossary
   *
   * @param glossaryGuid unique identifier for glossary term 
   * @param limit page size - by default there is no paging (optional, default to -1)
   * @param offset offset for pagination purpose (optional, default to 0)
   * @param sort ASC (default) or DESC (optional, default to ASC)
   * @return List[JsonAtlasRelatedCategoryHeader]
   */
  def getGlossaryCategoriesHeaders(glossaryGuid: String, limit: Option[String] = Option("-1"), offset: Option[String] = Option("0"), sort: Option[String] = Option("ASC")): Option[List[JsonAtlasRelatedCategoryHeader]] = {
    val await = Try(Await.result(getGlossaryCategoriesHeadersAsync(glossaryGuid, limit, offset, sort), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get the categories belonging to a specific glossary. asynchronously
   * Get the categories belonging to a specific glossary
   *
   * @param glossaryGuid unique identifier for glossary term 
   * @param limit page size - by default there is no paging (optional, default to -1)
   * @param offset offset for pagination purpose (optional, default to 0)
   * @param sort ASC (default) or DESC (optional, default to ASC)
   * @return Future(List[JsonAtlasRelatedCategoryHeader])
   */
  def getGlossaryCategoriesHeadersAsync(glossaryGuid: String, limit: Option[String] = Option("-1"), offset: Option[String] = Option("0"), sort: Option[String] = Option("ASC")): Future[List[JsonAtlasRelatedCategoryHeader]] = {
      helper.getGlossaryCategoriesHeaders(glossaryGuid, limit, offset, sort)
  }

  /**
   * Get specific glossary category.
   * Get specific glossary category
   *
   * @param categoryGuid unique identifier for glossary category 
   * @return JsonAtlasGlossaryCategory
   */
  def getGlossaryCategory(categoryGuid: String): Option[JsonAtlasGlossaryCategory] = {
    val await = Try(Await.result(getGlossaryCategoryAsync(categoryGuid), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get specific glossary category. asynchronously
   * Get specific glossary category
   *
   * @param categoryGuid unique identifier for glossary category 
   * @return Future(JsonAtlasGlossaryCategory)
   */
  def getGlossaryCategoryAsync(categoryGuid: String): Future[JsonAtlasGlossaryCategory] = {
      helper.getGlossaryCategory(categoryGuid)
  }

  /**
   * Get specific glossary term.
   * Get specific glossary term
   *
   * @param termGuid unique identifier for glossary term 
   * @return JsonAtlasGlossaryTerm
   */
  def getGlossaryTerm(termGuid: String): Option[JsonAtlasGlossaryTerm] = {
    val await = Try(Await.result(getGlossaryTermAsync(termGuid), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get specific glossary term. asynchronously
   * Get specific glossary term
   *
   * @param termGuid unique identifier for glossary term 
   * @return Future(JsonAtlasGlossaryTerm)
   */
  def getGlossaryTermAsync(termGuid: String): Future[JsonAtlasGlossaryTerm] = {
      helper.getGlossaryTerm(termGuid)
  }

  /**
   * Get term headers belonging to a specific glossary.
   * Get term headers belonging to a specific glossary
   *
   * @param glossaryGuid unique identifier for glossary 
   * @param limit page size - by default there is no paging (optional, default to -1)
   * @param offset starting offset for loading terms (optional, default to 0)
   * @param sort ASC(default) or DESC (optional, default to ASC)
   * @return List[JsonAtlasRelatedTermHeader]
   */
  def getGlossaryTermHeaders(glossaryGuid: String, limit: Option[String] = Option("-1"), offset: Option[String] = Option("0"), sort: Option[String] = Option("ASC")): Option[List[JsonAtlasRelatedTermHeader]] = {
    val await = Try(Await.result(getGlossaryTermHeadersAsync(glossaryGuid, limit, offset, sort), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get term headers belonging to a specific glossary. asynchronously
   * Get term headers belonging to a specific glossary
   *
   * @param glossaryGuid unique identifier for glossary 
   * @param limit page size - by default there is no paging (optional, default to -1)
   * @param offset starting offset for loading terms (optional, default to 0)
   * @param sort ASC(default) or DESC (optional, default to ASC)
   * @return Future(List[JsonAtlasRelatedTermHeader])
   */
  def getGlossaryTermHeadersAsync(glossaryGuid: String, limit: Option[String] = Option("-1"), offset: Option[String] = Option("0"), sort: Option[String] = Option("ASC")): Future[List[JsonAtlasRelatedTermHeader]] = {
      helper.getGlossaryTermHeaders(glossaryGuid, limit, offset, sort)
  }

  /**
   * Get terms belonging to a specific glossary.
   * Get terms belonging to a specific glossary
   *
   * @param glossaryGuid unique identifier for glossary 
   * @param limit page size - by default there is no paging (optional, default to -1)
   * @param offset starting offset for loading terms (optional, default to 0)
   * @param sort ASC(default) or DESC (optional, default to ASC)
   * @return List[JsonAtlasGlossaryTerm]
   */
  def getGlossaryTerms(glossaryGuid: String, limit: Option[String] = Option("-1"), offset: Option[String] = Option("0"), sort: Option[String] = Option("ASC")): Option[List[JsonAtlasGlossaryTerm]] = {
    val await = Try(Await.result(getGlossaryTermsAsync(glossaryGuid, limit, offset, sort), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get terms belonging to a specific glossary. asynchronously
   * Get terms belonging to a specific glossary
   *
   * @param glossaryGuid unique identifier for glossary 
   * @param limit page size - by default there is no paging (optional, default to -1)
   * @param offset starting offset for loading terms (optional, default to 0)
   * @param sort ASC(default) or DESC (optional, default to ASC)
   * @return Future(List[JsonAtlasGlossaryTerm])
   */
  def getGlossaryTermsAsync(glossaryGuid: String, limit: Option[String] = Option("-1"), offset: Option[String] = Option("0"), sort: Option[String] = Option("ASC")): Future[List[JsonAtlasGlossaryTerm]] = {
      helper.getGlossaryTerms(glossaryGuid, limit, offset, sort)
  }

  /**
   * Get all related categories (parent and children).
   * Get all related categories (parent and children)
   *
   * @param categoryGuid unique identifier for glossary category 
   * @param limit page size - by default there is no paging (optional, default to -1)
   * @param offset offset for pagination purpose (optional, default to 0)
   * @param sort ASC (default) or DESC (optional, default to ASC)
   * @return Map[String, List[JsonAtlasRelatedCategoryHeader]]
   */
  def getRelatedCategories(categoryGuid: String, limit: Option[String] = Option("-1"), offset: Option[String] = Option("0"), sort: Option[String] = Option("ASC")): Option[Map[String, List[JsonAtlasRelatedCategoryHeader]]] = {
    val await = Try(Await.result(getRelatedCategoriesAsync(categoryGuid, limit, offset, sort), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get all related categories (parent and children). asynchronously
   * Get all related categories (parent and children)
   *
   * @param categoryGuid unique identifier for glossary category 
   * @param limit page size - by default there is no paging (optional, default to -1)
   * @param offset offset for pagination purpose (optional, default to 0)
   * @param sort ASC (default) or DESC (optional, default to ASC)
   * @return Future(Map[String, List[JsonAtlasRelatedCategoryHeader]])
   */
  def getRelatedCategoriesAsync(categoryGuid: String, limit: Option[String] = Option("-1"), offset: Option[String] = Option("0"), sort: Option[String] = Option("ASC")): Future[Map[String, List[JsonAtlasRelatedCategoryHeader]]] = {
      helper.getRelatedCategories(categoryGuid, limit, offset, sort)
  }

  /**
   * Get all related terms for a specific term.
   * Get all related terms for a specific term
   *
   * @param termGuid unique identifier for glossary term 
   * @param limit page size - by default there is no paging (optional, default to -1)
   * @param offset offset for pagination purpose (optional, default to 0)
   * @param sort ASC (default) or DESC (optional, default to ASC)
   * @return Map[String, List[JsonAtlasRelatedTermHeader]]
   */
  def getRelatedTerms(termGuid: String, limit: Option[String] = Option("-1"), offset: Option[String] = Option("0"), sort: Option[String] = Option("ASC")): Option[Map[String, List[JsonAtlasRelatedTermHeader]]] = {
    val await = Try(Await.result(getRelatedTermsAsync(termGuid, limit, offset, sort), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get all related terms for a specific term. asynchronously
   * Get all related terms for a specific term
   *
   * @param termGuid unique identifier for glossary term 
   * @param limit page size - by default there is no paging (optional, default to -1)
   * @param offset offset for pagination purpose (optional, default to 0)
   * @param sort ASC (default) or DESC (optional, default to ASC)
   * @return Future(Map[String, List[JsonAtlasRelatedTermHeader]])
   */
  def getRelatedTermsAsync(termGuid: String, limit: Option[String] = Option("-1"), offset: Option[String] = Option("0"), sort: Option[String] = Option("ASC")): Future[Map[String, List[JsonAtlasRelatedTermHeader]]] = {
      helper.getRelatedTerms(termGuid, limit, offset, sort)
  }

  /**
   * Partially update the glossary.
   * Partially update the glossary
   *
   * @param glossaryGuid unique identifier for glossary term 
   * @param body Map containing keys as attribute names and values as corresponding attribute values (optional)
   * @return JsonAtlasGlossary
   */
  def partialUpdateGlossary(glossaryGuid: String, body: Option[Any] = None): Option[JsonAtlasGlossary] = {
    val await = Try(Await.result(partialUpdateGlossaryAsync(glossaryGuid, body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Partially update the glossary. asynchronously
   * Partially update the glossary
   *
   * @param glossaryGuid unique identifier for glossary term 
   * @param body Map containing keys as attribute names and values as corresponding attribute values (optional)
   * @return Future(JsonAtlasGlossary)
   */
  def partialUpdateGlossaryAsync(glossaryGuid: String, body: Option[Any] = None): Future[JsonAtlasGlossary] = {
      helper.partialUpdateGlossary(glossaryGuid, body)
  }

  /**
   * Partially update the glossary category.
   * Partially update the glossary category
   *
   * @param categoryGuid unique identifier for glossary term 
   * @param body Map containing keys as attribute names and values as corresponding attribute values (optional)
   * @return JsonAtlasGlossaryCategory
   */
  def partialUpdateGlossaryCategory(categoryGuid: String, body: Option[Any] = None): Option[JsonAtlasGlossaryCategory] = {
    val await = Try(Await.result(partialUpdateGlossaryCategoryAsync(categoryGuid, body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Partially update the glossary category. asynchronously
   * Partially update the glossary category
   *
   * @param categoryGuid unique identifier for glossary term 
   * @param body Map containing keys as attribute names and values as corresponding attribute values (optional)
   * @return Future(JsonAtlasGlossaryCategory)
   */
  def partialUpdateGlossaryCategoryAsync(categoryGuid: String, body: Option[Any] = None): Future[JsonAtlasGlossaryCategory] = {
      helper.partialUpdateGlossaryCategory(categoryGuid, body)
  }

  /**
   * Partially update the glossary term.
   * Partially update the glossary term
   *
   * @param termGuid unique identifier for glossary term 
   * @param body Map containing keys as attribute names and values as corresponding attribute values (optional)
   * @return JsonAtlasGlossaryTerm
   */
  def partialUpdateGlossaryTerm(termGuid: String, body: Option[Any] = None): Option[JsonAtlasGlossaryTerm] = {
    val await = Try(Await.result(partialUpdateGlossaryTermAsync(termGuid, body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Partially update the glossary term. asynchronously
   * Partially update the glossary term
   *
   * @param termGuid unique identifier for glossary term 
   * @param body Map containing keys as attribute names and values as corresponding attribute values (optional)
   * @return Future(JsonAtlasGlossaryTerm)
   */
  def partialUpdateGlossaryTermAsync(termGuid: String, body: Option[Any] = None): Future[JsonAtlasGlossaryTerm] = {
      helper.partialUpdateGlossaryTerm(termGuid, body)
  }

  /**
   * Remove the term assignment for the given list of entity headers.
   * Remove the term assignment for the given list of entity headers
   *
   * @param termGuid Glossary term GUID 
   * @param body List of related entity IDs from which the term has to be dissociated (optional)
   * @return void
   */
  def removeTermAssignmentFromEntities(termGuid: String, body: Option[List[JsonAtlasRelatedObjectId]] = None) = {
    val await = Try(Await.result(removeTermAssignmentFromEntitiesAsync(termGuid, body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Remove the term assignment for the given list of entity headers. asynchronously
   * Remove the term assignment for the given list of entity headers
   *
   * @param termGuid Glossary term GUID 
   * @param body List of related entity IDs from which the term has to be dissociated (optional)
   * @return Future(void)
   */
  def removeTermAssignmentFromEntitiesAsync(termGuid: String, body: Option[List[JsonAtlasRelatedObjectId]] = None) = {
      helper.removeTermAssignmentFromEntities(termGuid, body)
  }

  /**
   * Update the given glossary.
   * Update the given glossary
   *
   * @param glossaryGuid unique identifier for glossary 
   * @param body Updated glossary definition (optional)
   * @return JsonAtlasGlossary
   */
  def updateGlossary(glossaryGuid: String, body: Option[JsonAtlasGlossary] = None): Option[JsonAtlasGlossary] = {
    val await = Try(Await.result(updateGlossaryAsync(glossaryGuid, body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update the given glossary. asynchronously
   * Update the given glossary
   *
   * @param glossaryGuid unique identifier for glossary 
   * @param body Updated glossary definition (optional)
   * @return Future(JsonAtlasGlossary)
   */
  def updateGlossaryAsync(glossaryGuid: String, body: Option[JsonAtlasGlossary] = None): Future[JsonAtlasGlossary] = {
      helper.updateGlossary(glossaryGuid, body)
  }

  /**
   * Update the given glossary category.
   * Update the given glossary category
   *
   * @param categoryGuid unique identifier for glossary category 
   * @param body updated glossary category (optional)
   * @return JsonAtlasGlossaryCategory
   */
  def updateGlossaryCategory(categoryGuid: String, body: Option[JsonAtlasGlossaryCategory] = None): Option[JsonAtlasGlossaryCategory] = {
    val await = Try(Await.result(updateGlossaryCategoryAsync(categoryGuid, body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update the given glossary category. asynchronously
   * Update the given glossary category
   *
   * @param categoryGuid unique identifier for glossary category 
   * @param body updated glossary category (optional)
   * @return Future(JsonAtlasGlossaryCategory)
   */
  def updateGlossaryCategoryAsync(categoryGuid: String, body: Option[JsonAtlasGlossaryCategory] = None): Future[JsonAtlasGlossaryCategory] = {
      helper.updateGlossaryCategory(categoryGuid, body)
  }

  /**
   * Update the given glossary term.
   * Update the given glossary term
   *
   * @param termGuid unique identifier for glossary term 
   * @param body updated glossary term (optional)
   * @return JsonAtlasGlossaryTerm
   */
  def updateGlossaryTerm(termGuid: String, body: Option[JsonAtlasGlossaryTerm] = None): Option[JsonAtlasGlossaryTerm] = {
    val await = Try(Await.result(updateGlossaryTermAsync(termGuid, body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update the given glossary term. asynchronously
   * Update the given glossary term
   *
   * @param termGuid unique identifier for glossary term 
   * @param body updated glossary term (optional)
   * @return Future(JsonAtlasGlossaryTerm)
   */
  def updateGlossaryTermAsync(termGuid: String, body: Option[JsonAtlasGlossaryTerm] = None): Future[JsonAtlasGlossaryTerm] = {
      helper.updateGlossaryTerm(termGuid, body)
  }

}

class GlossaryRESTApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def assignTermToEntities(termGuid: String,
    body: Option[List[JsonAtlasRelatedObjectId]] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[Option[List[JsonAtlasRelatedObjectId]]]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/v2/glossary/terms/{termGuid}/assignedEntities")
      replaceAll("\\{" + "termGuid" + "\\}", termGuid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (termGuid == null) throw new Exception("Missing required parameter 'termGuid' when calling GlossaryRESTApi->assignTermToEntities")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createGlossary(body: Option[JsonAtlasGlossary] = None
    )(implicit reader: ClientResponseReader[JsonAtlasGlossary], writer: RequestWriter[Option[JsonAtlasGlossary]]): Future[JsonAtlasGlossary] = {
    // create path and map variables
    val path = (addFmt("/v2/glossary"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createGlossaryCategories(body: Option[List[JsonAtlasGlossaryCategory]] = None
    )(implicit reader: ClientResponseReader[List[JsonAtlasGlossaryCategory]], writer: RequestWriter[Option[List[JsonAtlasGlossaryCategory]]]): Future[List[JsonAtlasGlossaryCategory]] = {
    // create path and map variables
    val path = (addFmt("/v2/glossary/categories"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createGlossaryCategory(body: Option[JsonAtlasGlossaryCategory] = None
    )(implicit reader: ClientResponseReader[JsonAtlasGlossaryCategory], writer: RequestWriter[Option[JsonAtlasGlossaryCategory]]): Future[JsonAtlasGlossaryCategory] = {
    // create path and map variables
    val path = (addFmt("/v2/glossary/category"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createGlossaryTerm(body: Option[JsonAtlasGlossaryTerm] = None
    )(implicit reader: ClientResponseReader[JsonAtlasGlossaryTerm], writer: RequestWriter[Option[JsonAtlasGlossaryTerm]]): Future[JsonAtlasGlossaryTerm] = {
    // create path and map variables
    val path = (addFmt("/v2/glossary/term"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createGlossaryTerms(body: Option[List[JsonAtlasGlossaryTerm]] = None
    )(implicit reader: ClientResponseReader[List[JsonAtlasGlossaryTerm]], writer: RequestWriter[Option[List[JsonAtlasGlossaryTerm]]]): Future[List[JsonAtlasGlossaryTerm]] = {
    // create path and map variables
    val path = (addFmt("/v2/glossary/terms"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteGlossary(glossaryGuid: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/v2/glossary/{glossaryGuid}")
      replaceAll("\\{" + "glossaryGuid" + "\\}", glossaryGuid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (glossaryGuid == null) throw new Exception("Missing required parameter 'glossaryGuid' when calling GlossaryRESTApi->deleteGlossary")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteGlossaryCategory(categoryGuid: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/v2/glossary/category/{categoryGuid}")
      replaceAll("\\{" + "categoryGuid" + "\\}", categoryGuid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (categoryGuid == null) throw new Exception("Missing required parameter 'categoryGuid' when calling GlossaryRESTApi->deleteGlossaryCategory")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteGlossaryTerm(termGuid: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/v2/glossary/term/{termGuid}")
      replaceAll("\\{" + "termGuid" + "\\}", termGuid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (termGuid == null) throw new Exception("Missing required parameter 'termGuid' when calling GlossaryRESTApi->deleteGlossaryTerm")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def disassociateTermAssignmentFromEntities(termGuid: String,
    body: Option[List[JsonAtlasRelatedObjectId]] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[Option[List[JsonAtlasRelatedObjectId]]]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/v2/glossary/terms/{termGuid}/assignedEntities")
      replaceAll("\\{" + "termGuid" + "\\}", termGuid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (termGuid == null) throw new Exception("Missing required parameter 'termGuid' when calling GlossaryRESTApi->disassociateTermAssignmentFromEntities")


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getCategoryTerms(categoryGuid: String,
    limit: Option[String] = Option("-1"),
    offset: Option[String] = Option("0"),
    sort: Option[String] = Option("ASC")
    )(implicit reader: ClientResponseReader[List[JsonAtlasRelatedTermHeader]]): Future[List[JsonAtlasRelatedTermHeader]] = {
    // create path and map variables
    val path = (addFmt("/v2/glossary/category/{categoryGuid}/terms")
      replaceAll("\\{" + "categoryGuid" + "\\}", categoryGuid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (categoryGuid == null) throw new Exception("Missing required parameter 'categoryGuid' when calling GlossaryRESTApi->getCategoryTerms")

    limit match {
      case Some(param) => queryParams += "limit" -> param.toString
      case _ => queryParams
    }
    offset match {
      case Some(param) => queryParams += "offset" -> param.toString
      case _ => queryParams
    }
    sort match {
      case Some(param) => queryParams += "sort" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getDetailedGlossary(glossaryGuid: String)(implicit reader: ClientResponseReader[JsonAtlasGlossaryExtInfo]): Future[JsonAtlasGlossaryExtInfo] = {
    // create path and map variables
    val path = (addFmt("/v2/glossary/{glossaryGuid}/detailed")
      replaceAll("\\{" + "glossaryGuid" + "\\}", glossaryGuid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (glossaryGuid == null) throw new Exception("Missing required parameter 'glossaryGuid' when calling GlossaryRESTApi->getDetailedGlossary")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getEntitiesAssignedWithTerm(termGuid: String,
    limit: Option[String] = Option("-1"),
    offset: Option[String] = Option("0"),
    sort: Option[String] = Option("ASC")
    )(implicit reader: ClientResponseReader[List[JsonAtlasRelatedObjectId]]): Future[List[JsonAtlasRelatedObjectId]] = {
    // create path and map variables
    val path = (addFmt("/v2/glossary/terms/{termGuid}/assignedEntities")
      replaceAll("\\{" + "termGuid" + "\\}", termGuid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (termGuid == null) throw new Exception("Missing required parameter 'termGuid' when calling GlossaryRESTApi->getEntitiesAssignedWithTerm")

    limit match {
      case Some(param) => queryParams += "limit" -> param.toString
      case _ => queryParams
    }
    offset match {
      case Some(param) => queryParams += "offset" -> param.toString
      case _ => queryParams
    }
    sort match {
      case Some(param) => queryParams += "sort" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getGlossaries(limit: Option[String] = Option("-1"),
    offset: Option[String] = Option("0"),
    sort: Option[String] = Option("ASC")
    )(implicit reader: ClientResponseReader[List[JsonAtlasGlossary]]): Future[List[JsonAtlasGlossary]] = {
    // create path and map variables
    val path = (addFmt("/v2/glossary"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    limit match {
      case Some(param) => queryParams += "limit" -> param.toString
      case _ => queryParams
    }
    offset match {
      case Some(param) => queryParams += "offset" -> param.toString
      case _ => queryParams
    }
    sort match {
      case Some(param) => queryParams += "sort" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getGlossary(glossaryGuid: String)(implicit reader: ClientResponseReader[JsonAtlasGlossary]): Future[JsonAtlasGlossary] = {
    // create path and map variables
    val path = (addFmt("/v2/glossary/{glossaryGuid}")
      replaceAll("\\{" + "glossaryGuid" + "\\}", glossaryGuid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (glossaryGuid == null) throw new Exception("Missing required parameter 'glossaryGuid' when calling GlossaryRESTApi->getGlossary")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getGlossaryCategories(glossaryGuid: String,
    limit: Option[String] = Option("-1"),
    offset: Option[String] = Option("0"),
    sort: Option[String] = Option("ASC")
    )(implicit reader: ClientResponseReader[List[JsonAtlasGlossaryCategory]]): Future[List[JsonAtlasGlossaryCategory]] = {
    // create path and map variables
    val path = (addFmt("/v2/glossary/{glossaryGuid}/categories")
      replaceAll("\\{" + "glossaryGuid" + "\\}", glossaryGuid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (glossaryGuid == null) throw new Exception("Missing required parameter 'glossaryGuid' when calling GlossaryRESTApi->getGlossaryCategories")

    limit match {
      case Some(param) => queryParams += "limit" -> param.toString
      case _ => queryParams
    }
    offset match {
      case Some(param) => queryParams += "offset" -> param.toString
      case _ => queryParams
    }
    sort match {
      case Some(param) => queryParams += "sort" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getGlossaryCategoriesHeaders(glossaryGuid: String,
    limit: Option[String] = Option("-1"),
    offset: Option[String] = Option("0"),
    sort: Option[String] = Option("ASC")
    )(implicit reader: ClientResponseReader[List[JsonAtlasRelatedCategoryHeader]]): Future[List[JsonAtlasRelatedCategoryHeader]] = {
    // create path and map variables
    val path = (addFmt("/v2/glossary/{glossaryGuid}/categories/headers")
      replaceAll("\\{" + "glossaryGuid" + "\\}", glossaryGuid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (glossaryGuid == null) throw new Exception("Missing required parameter 'glossaryGuid' when calling GlossaryRESTApi->getGlossaryCategoriesHeaders")

    limit match {
      case Some(param) => queryParams += "limit" -> param.toString
      case _ => queryParams
    }
    offset match {
      case Some(param) => queryParams += "offset" -> param.toString
      case _ => queryParams
    }
    sort match {
      case Some(param) => queryParams += "sort" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getGlossaryCategory(categoryGuid: String)(implicit reader: ClientResponseReader[JsonAtlasGlossaryCategory]): Future[JsonAtlasGlossaryCategory] = {
    // create path and map variables
    val path = (addFmt("/v2/glossary/category/{categoryGuid}")
      replaceAll("\\{" + "categoryGuid" + "\\}", categoryGuid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (categoryGuid == null) throw new Exception("Missing required parameter 'categoryGuid' when calling GlossaryRESTApi->getGlossaryCategory")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getGlossaryTerm(termGuid: String)(implicit reader: ClientResponseReader[JsonAtlasGlossaryTerm]): Future[JsonAtlasGlossaryTerm] = {
    // create path and map variables
    val path = (addFmt("/v2/glossary/term/{termGuid}")
      replaceAll("\\{" + "termGuid" + "\\}", termGuid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (termGuid == null) throw new Exception("Missing required parameter 'termGuid' when calling GlossaryRESTApi->getGlossaryTerm")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getGlossaryTermHeaders(glossaryGuid: String,
    limit: Option[String] = Option("-1"),
    offset: Option[String] = Option("0"),
    sort: Option[String] = Option("ASC")
    )(implicit reader: ClientResponseReader[List[JsonAtlasRelatedTermHeader]]): Future[List[JsonAtlasRelatedTermHeader]] = {
    // create path and map variables
    val path = (addFmt("/v2/glossary/{glossaryGuid}/terms/headers")
      replaceAll("\\{" + "glossaryGuid" + "\\}", glossaryGuid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (glossaryGuid == null) throw new Exception("Missing required parameter 'glossaryGuid' when calling GlossaryRESTApi->getGlossaryTermHeaders")

    limit match {
      case Some(param) => queryParams += "limit" -> param.toString
      case _ => queryParams
    }
    offset match {
      case Some(param) => queryParams += "offset" -> param.toString
      case _ => queryParams
    }
    sort match {
      case Some(param) => queryParams += "sort" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getGlossaryTerms(glossaryGuid: String,
    limit: Option[String] = Option("-1"),
    offset: Option[String] = Option("0"),
    sort: Option[String] = Option("ASC")
    )(implicit reader: ClientResponseReader[List[JsonAtlasGlossaryTerm]]): Future[List[JsonAtlasGlossaryTerm]] = {
    // create path and map variables
    val path = (addFmt("/v2/glossary/{glossaryGuid}/terms")
      replaceAll("\\{" + "glossaryGuid" + "\\}", glossaryGuid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (glossaryGuid == null) throw new Exception("Missing required parameter 'glossaryGuid' when calling GlossaryRESTApi->getGlossaryTerms")

    limit match {
      case Some(param) => queryParams += "limit" -> param.toString
      case _ => queryParams
    }
    offset match {
      case Some(param) => queryParams += "offset" -> param.toString
      case _ => queryParams
    }
    sort match {
      case Some(param) => queryParams += "sort" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getRelatedCategories(categoryGuid: String,
    limit: Option[String] = Option("-1"),
    offset: Option[String] = Option("0"),
    sort: Option[String] = Option("ASC")
    )(implicit reader: ClientResponseReader[Map[String, List[JsonAtlasRelatedCategoryHeader]]]): Future[Map[String, List[JsonAtlasRelatedCategoryHeader]]] = {
    // create path and map variables
    val path = (addFmt("/v2/glossary/category/{categoryGuid}/related")
      replaceAll("\\{" + "categoryGuid" + "\\}", categoryGuid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (categoryGuid == null) throw new Exception("Missing required parameter 'categoryGuid' when calling GlossaryRESTApi->getRelatedCategories")

    limit match {
      case Some(param) => queryParams += "limit" -> param.toString
      case _ => queryParams
    }
    offset match {
      case Some(param) => queryParams += "offset" -> param.toString
      case _ => queryParams
    }
    sort match {
      case Some(param) => queryParams += "sort" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getRelatedTerms(termGuid: String,
    limit: Option[String] = Option("-1"),
    offset: Option[String] = Option("0"),
    sort: Option[String] = Option("ASC")
    )(implicit reader: ClientResponseReader[Map[String, List[JsonAtlasRelatedTermHeader]]]): Future[Map[String, List[JsonAtlasRelatedTermHeader]]] = {
    // create path and map variables
    val path = (addFmt("/v2/glossary/terms/{termGuid}/related")
      replaceAll("\\{" + "termGuid" + "\\}", termGuid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (termGuid == null) throw new Exception("Missing required parameter 'termGuid' when calling GlossaryRESTApi->getRelatedTerms")

    limit match {
      case Some(param) => queryParams += "limit" -> param.toString
      case _ => queryParams
    }
    offset match {
      case Some(param) => queryParams += "offset" -> param.toString
      case _ => queryParams
    }
    sort match {
      case Some(param) => queryParams += "sort" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def partialUpdateGlossary(glossaryGuid: String,
    body: Option[Any] = None
    )(implicit reader: ClientResponseReader[JsonAtlasGlossary], writer: RequestWriter[Option[Any]]): Future[JsonAtlasGlossary] = {
    // create path and map variables
    val path = (addFmt("/v2/glossary/{glossaryGuid}/partial")
      replaceAll("\\{" + "glossaryGuid" + "\\}", glossaryGuid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (glossaryGuid == null) throw new Exception("Missing required parameter 'glossaryGuid' when calling GlossaryRESTApi->partialUpdateGlossary")


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def partialUpdateGlossaryCategory(categoryGuid: String,
    body: Option[Any] = None
    )(implicit reader: ClientResponseReader[JsonAtlasGlossaryCategory], writer: RequestWriter[Option[Any]]): Future[JsonAtlasGlossaryCategory] = {
    // create path and map variables
    val path = (addFmt("/v2/glossary/category/{categoryGuid}/partial")
      replaceAll("\\{" + "categoryGuid" + "\\}", categoryGuid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (categoryGuid == null) throw new Exception("Missing required parameter 'categoryGuid' when calling GlossaryRESTApi->partialUpdateGlossaryCategory")


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def partialUpdateGlossaryTerm(termGuid: String,
    body: Option[Any] = None
    )(implicit reader: ClientResponseReader[JsonAtlasGlossaryTerm], writer: RequestWriter[Option[Any]]): Future[JsonAtlasGlossaryTerm] = {
    // create path and map variables
    val path = (addFmt("/v2/glossary/term/{termGuid}/partial")
      replaceAll("\\{" + "termGuid" + "\\}", termGuid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (termGuid == null) throw new Exception("Missing required parameter 'termGuid' when calling GlossaryRESTApi->partialUpdateGlossaryTerm")


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def removeTermAssignmentFromEntities(termGuid: String,
    body: Option[List[JsonAtlasRelatedObjectId]] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[Option[List[JsonAtlasRelatedObjectId]]]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/v2/glossary/terms/{termGuid}/assignedEntities")
      replaceAll("\\{" + "termGuid" + "\\}", termGuid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (termGuid == null) throw new Exception("Missing required parameter 'termGuid' when calling GlossaryRESTApi->removeTermAssignmentFromEntities")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateGlossary(glossaryGuid: String,
    body: Option[JsonAtlasGlossary] = None
    )(implicit reader: ClientResponseReader[JsonAtlasGlossary], writer: RequestWriter[Option[JsonAtlasGlossary]]): Future[JsonAtlasGlossary] = {
    // create path and map variables
    val path = (addFmt("/v2/glossary/{glossaryGuid}")
      replaceAll("\\{" + "glossaryGuid" + "\\}", glossaryGuid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (glossaryGuid == null) throw new Exception("Missing required parameter 'glossaryGuid' when calling GlossaryRESTApi->updateGlossary")


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateGlossaryCategory(categoryGuid: String,
    body: Option[JsonAtlasGlossaryCategory] = None
    )(implicit reader: ClientResponseReader[JsonAtlasGlossaryCategory], writer: RequestWriter[Option[JsonAtlasGlossaryCategory]]): Future[JsonAtlasGlossaryCategory] = {
    // create path and map variables
    val path = (addFmt("/v2/glossary/category/{categoryGuid}")
      replaceAll("\\{" + "categoryGuid" + "\\}", categoryGuid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (categoryGuid == null) throw new Exception("Missing required parameter 'categoryGuid' when calling GlossaryRESTApi->updateGlossaryCategory")


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateGlossaryTerm(termGuid: String,
    body: Option[JsonAtlasGlossaryTerm] = None
    )(implicit reader: ClientResponseReader[JsonAtlasGlossaryTerm], writer: RequestWriter[Option[JsonAtlasGlossaryTerm]]): Future[JsonAtlasGlossaryTerm] = {
    // create path and map variables
    val path = (addFmt("/v2/glossary/term/{termGuid}")
      replaceAll("\\{" + "termGuid" + "\\}", termGuid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (termGuid == null) throw new Exception("Missing required parameter 'termGuid' when calling GlossaryRESTApi->updateGlossaryTerm")


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
