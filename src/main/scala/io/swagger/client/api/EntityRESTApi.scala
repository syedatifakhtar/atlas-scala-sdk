/**
 * Atlas REST API
 * Atlas exposes a variety of REST endpoints to work with types, entities, lineage and data discovery.
 *
 * OpenAPI spec version: 2.0.0-SNAPSHOT
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api

import java.text.SimpleDateFormat

import io.swagger.client.model.JsonAtlasClassification
import io.swagger.client.model.JsonAtlasClassifications
import io.swagger.client.model.JsonAtlasEntitiesWithExtInfo
import io.swagger.client.model.JsonAtlasEntityHeader
import io.swagger.client.model.JsonAtlasEntityWithExtInfo
import io.swagger.client.model.JsonClassificationAssociateRequest
import io.swagger.client.model.JsonEntityAuditEventV2
import io.swagger.client.model.JsonEntityMutationResponse
import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date
import java.util.TimeZone

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

import org.json4s._

class EntityRESTApi(
  val defBasePath: String = "https://localhost:21000",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new EntityRESTApiAsyncHelper(client, config)

  /**
   * Bulk API to associate a tag to multiple entities.
   * Bulk API to associate a tag to multiple entities
   *
   * @param body  (optional)
   * @return void
   */
  def addClassification(body: Option[JsonClassificationAssociateRequest] = None) = {
    val await = Try(Await.result(addClassificationAsync(body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Bulk API to associate a tag to multiple entities. asynchronously
   * Bulk API to associate a tag to multiple entities
   *
   * @param body  (optional)
   * @return Future(void)
   */
  def addClassificationAsync(body: Option[JsonClassificationAssociateRequest] = None) = {
      helper.addClassification(body)
  }

  /**
   * Adds classifications to an existing entity represented by a guid.
   * Adds classifications to an existing entity represented by a guid.
   *
   * @param guid globally unique identifier for the entity 
   * @param body  (optional)
   * @return void
   */
  def addClassifications(guid: String, body: Option[List[JsonAtlasClassification]] = None) = {
    val await = Try(Await.result(addClassificationsAsync(guid, body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Adds classifications to an existing entity represented by a guid. asynchronously
   * Adds classifications to an existing entity represented by a guid.
   *
   * @param guid globally unique identifier for the entity 
   * @param body  (optional)
   * @return Future(void)
   */
  def addClassificationsAsync(guid: String, body: Option[List[JsonAtlasClassification]] = None) = {
      helper.addClassifications(guid, body)
  }

  /**
   * Adds classification to the entity identified by its type and unique attributes.
   * Adds classification to the entity identified by its type and unique attributes.
   *
   * @param typeName  
   * @param body  (optional)
   * @return void
   */
  def addClassificationsByUniqueAttribute(typeName: String, body: Option[List[JsonAtlasClassification]] = None) = {
    val await = Try(Await.result(addClassificationsByUniqueAttributeAsync(typeName, body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Adds classification to the entity identified by its type and unique attributes. asynchronously
   * Adds classification to the entity identified by its type and unique attributes.
   *
   * @param typeName  
   * @param body  (optional)
   * @return Future(void)
   */
  def addClassificationsByUniqueAttributeAsync(typeName: String, body: Option[List[JsonAtlasClassification]] = None) = {
      helper.addClassificationsByUniqueAttribute(typeName, body)
  }

  /**
   * Bulk API to create new entities or updates existing entities in Atlas.
   * Bulk API to create new entities or updates existing entities in Atlas. Existing entity is matched using its unique guid if supplied or by its unique attributes eg: qualifiedName
   *
   * @param body  (optional)
   * @return JsonEntityMutationResponse
   */
  def createOrUpdateEntities(body: Option[JsonAtlasEntitiesWithExtInfo] = None): Option[JsonEntityMutationResponse] = {
    val await = Try(Await.result(createOrUpdateEntitiesAsync(body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Bulk API to create new entities or updates existing entities in Atlas. asynchronously
   * Bulk API to create new entities or updates existing entities in Atlas. Existing entity is matched using its unique guid if supplied or by its unique attributes eg: qualifiedName
   *
   * @param body  (optional)
   * @return Future(JsonEntityMutationResponse)
   */
  def createOrUpdateEntitiesAsync(body: Option[JsonAtlasEntitiesWithExtInfo] = None): Future[JsonEntityMutationResponse] = {
      helper.createOrUpdateEntities(body)
  }

  /**
   * Create new entity or update existing entity in Atlas.
   * Create new entity or update existing entity in Atlas. Existing entity is matched using its unique guid if supplied or by its unique attributes eg: qualifiedName
   *
   * @param body  (optional)
   * @return JsonEntityMutationResponse
   */
  def createOrUpdateSingleEntity(body: Option[JsonAtlasEntityWithExtInfo] = None): Option[JsonEntityMutationResponse] = {
    val await = Try(Await.result(createOrUpdateSingleEntityAsync(body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create new entity or update existing entity in Atlas. asynchronously
   * Create new entity or update existing entity in Atlas. Existing entity is matched using its unique guid if supplied or by its unique attributes eg: qualifiedName
   *
   * @param body  (optional)
   * @return Future(JsonEntityMutationResponse)
   */
  def createOrUpdateSingleEntityAsync(body: Option[JsonAtlasEntityWithExtInfo] = None): Future[JsonEntityMutationResponse] = {
      helper.createOrUpdateSingleEntity(body)
  }

  /**
   * Delete an entity identified by its GUID.
   * Delete an entity identified by its GUID.
   *
   * @param guid GUID for the entity 
   * @return JsonEntityMutationResponse
   */
  def deleteByGuid(guid: String): Option[JsonEntityMutationResponse] = {
    val await = Try(Await.result(deleteByGuidAsync(guid), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete an entity identified by its GUID. asynchronously
   * Delete an entity identified by its GUID.
   *
   * @param guid GUID for the entity 
   * @return Future(JsonEntityMutationResponse)
   */
  def deleteByGuidAsync(guid: String): Future[JsonEntityMutationResponse] = {
      helper.deleteByGuid(guid)
  }

  /**
   * Bulk API to delete list of entities identified by its GUIDs.
   * Bulk API to delete list of entities identified by its GUIDs
   *
   * @param guid  (optional)
   * @return JsonEntityMutationResponse
   */
  def deleteByGuids(guid: Option[List[String]] = None): Option[JsonEntityMutationResponse] = {
    val await = Try(Await.result(deleteByGuidsAsync(guid), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Bulk API to delete list of entities identified by its GUIDs. asynchronously
   * Bulk API to delete list of entities identified by its GUIDs
   *
   * @param guid  (optional)
   * @return Future(JsonEntityMutationResponse)
   */
  def deleteByGuidsAsync(guid: Option[List[String]] = None): Future[JsonEntityMutationResponse] = {
      helper.deleteByGuids(guid)
  }

  /**
   * Delete an entity identified by its type and unique attributes.
   * Delete an entity identified by its type and unique attributes.  In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the following format  attr:&lt;attrName&gt;&#x3D;&lt;attrValue&gt;  NOTE: The attrName and attrValue should be unique across entities, eg. qualifiedName  The REST request would look something like this  DELETE /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute&#x3D;someValue
   *
   * @param typeName - entity type to be deleted 
   * @return JsonEntityMutationResponse
   */
  def deleteByUniqueAttribute(typeName: String): Option[JsonEntityMutationResponse] = {
    val await = Try(Await.result(deleteByUniqueAttributeAsync(typeName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete an entity identified by its type and unique attributes. asynchronously
   * Delete an entity identified by its type and unique attributes.  In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the following format  attr:&lt;attrName&gt;&#x3D;&lt;attrValue&gt;  NOTE: The attrName and attrValue should be unique across entities, eg. qualifiedName  The REST request would look something like this  DELETE /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute&#x3D;someValue
   *
   * @param typeName - entity type to be deleted 
   * @return Future(JsonEntityMutationResponse)
   */
  def deleteByUniqueAttributeAsync(typeName: String): Future[JsonEntityMutationResponse] = {
      helper.deleteByUniqueAttribute(typeName)
  }

  /**
   * Deletes a given classification from an existing entity represented by a guid.
   * Deletes a given classification from an existing entity represented by a guid.
   *
   * @param classificationName name of the classifcation 
   * @param guid globally unique identifier for the entity 
   * @param associatedEntityGuid  (optional)
   * @return void
   */
  def deleteClassification(classificationName: String, guid: String, associatedEntityGuid: Option[String] = None) = {
    val await = Try(Await.result(deleteClassificationAsync(classificationName, guid, associatedEntityGuid), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Deletes a given classification from an existing entity represented by a guid. asynchronously
   * Deletes a given classification from an existing entity represented by a guid.
   *
   * @param classificationName name of the classifcation 
   * @param guid globally unique identifier for the entity 
   * @param associatedEntityGuid  (optional)
   * @return Future(void)
   */
  def deleteClassificationAsync(classificationName: String, guid: String, associatedEntityGuid: Option[String] = None) = {
      helper.deleteClassification(classificationName, guid, associatedEntityGuid)
  }

  /**
   * Deletes a given classification from an entity identified by its type and unique attributes.
   * Deletes a given classification from an entity identified by its type and unique attributes.
   *
   * @param classificationName name of the classification 
   * @param typeName  
   * @return void
   */
  def deleteClassificationByUniqueAttribute(classificationName: String, typeName: String) = {
    val await = Try(Await.result(deleteClassificationByUniqueAttributeAsync(classificationName, typeName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Deletes a given classification from an entity identified by its type and unique attributes. asynchronously
   * Deletes a given classification from an entity identified by its type and unique attributes.
   *
   * @param classificationName name of the classification 
   * @param typeName  
   * @return Future(void)
   */
  def deleteClassificationByUniqueAttributeAsync(classificationName: String, typeName: String) = {
      helper.deleteClassificationByUniqueAttribute(classificationName, typeName)
  }

  /**
   * 
   * 
   *
   * @param guid  
   * @param count  (optional, default to 100)
   * @param startKey  (optional)
   * @return List[JsonEntityAuditEventV2]
   */
  def getAuditEvents(guid: String, count: Option[Integer] = Option(100), startKey: Option[String] = None): Option[List[JsonEntityAuditEventV2]] = {
    val await = Try(Await.result(getAuditEventsAsync(guid, count, startKey), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param guid  
   * @param count  (optional, default to 100)
   * @param startKey  (optional)
   * @return Future(List[JsonEntityAuditEventV2])
   */
  def getAuditEventsAsync(guid: String, count: Option[Integer] = Option(100), startKey: Option[String] = None): Future[List[JsonEntityAuditEventV2]] = {
      helper.getAuditEvents(guid, count, startKey)
  }

  /**
   * Bulk API to retrieve list of entities identified by its GUIDs.
   * Bulk API to retrieve list of entities identified by its GUIDs.
   *
   * @param guid  (optional)
   * @param ignoreRelationships  (optional, default to false)
   * @param minExtInfo  (optional, default to false)
   * @return JsonAtlasEntitiesWithExtInfo
   */
  def getByGuids(guid: Option[List[String]] = None, ignoreRelationships: Option[Boolean] = Option(false), minExtInfo: Option[Boolean] = Option(false)): Option[JsonAtlasEntitiesWithExtInfo] = {
    val await = Try(Await.result(getByGuidsAsync(guid, ignoreRelationships, minExtInfo), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Bulk API to retrieve list of entities identified by its GUIDs. asynchronously
   * Bulk API to retrieve list of entities identified by its GUIDs.
   *
   * @param guid  (optional)
   * @param ignoreRelationships  (optional, default to false)
   * @param minExtInfo  (optional, default to false)
   * @return Future(JsonAtlasEntitiesWithExtInfo)
   */
  def getByGuidsAsync(guid: Option[List[String]] = None, ignoreRelationships: Option[Boolean] = Option(false), minExtInfo: Option[Boolean] = Option(false)): Future[JsonAtlasEntitiesWithExtInfo] = {
      helper.getByGuids(guid, ignoreRelationships, minExtInfo)
  }

  /**
   * Fetch complete definition of an entity given its GUID.
   * Fetch complete definition of an entity given its GUID.
   *
   * @param guid GUID for the entity 
   * @param ignoreRelationships  (optional, default to false)
   * @param minExtInfo  (optional, default to false)
   * @return JsonAtlasEntityWithExtInfo
   */
  def getById(guid: String, ignoreRelationships: Option[Boolean] = Option(false), minExtInfo: Option[Boolean] = Option(false)): Option[JsonAtlasEntityWithExtInfo] = {
    val await = Try(Await.result(getByIdAsync(guid, ignoreRelationships, minExtInfo), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Fetch complete definition of an entity given its GUID. asynchronously
   * Fetch complete definition of an entity given its GUID.
   *
   * @param guid GUID for the entity 
   * @param ignoreRelationships  (optional, default to false)
   * @param minExtInfo  (optional, default to false)
   * @return Future(JsonAtlasEntityWithExtInfo)
   */
  def getByIdAsync(guid: String, ignoreRelationships: Option[Boolean] = Option(false), minExtInfo: Option[Boolean] = Option(false)): Future[JsonAtlasEntityWithExtInfo] = {
      helper.getById(guid, ignoreRelationships, minExtInfo)
  }

  /**
   * Fetch complete definition of an entity given its type and unique attribute.
   * Fetch complete definition of an entity given its type and unique attribute.  In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the following format  attr:&lt;attrName&gt;&#x3D;&lt;attrValue&gt;  NOTE: The attrName and attrValue should be unique across entities, eg. qualifiedName  The REST request would look something like this  GET /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute&#x3D;someValue
   *
   * @param typeName  
   * @param ignoreRelationships  (optional, default to false)
   * @param minExtInfo  (optional, default to false)
   * @return JsonAtlasEntityWithExtInfo
   */
  def getByUniqueAttributes(typeName: String, ignoreRelationships: Option[Boolean] = Option(false), minExtInfo: Option[Boolean] = Option(false)): Option[JsonAtlasEntityWithExtInfo] = {
    val await = Try(Await.result(getByUniqueAttributesAsync(typeName, ignoreRelationships, minExtInfo), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Fetch complete definition of an entity given its type and unique attribute. asynchronously
   * Fetch complete definition of an entity given its type and unique attribute.  In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the following format  attr:&lt;attrName&gt;&#x3D;&lt;attrValue&gt;  NOTE: The attrName and attrValue should be unique across entities, eg. qualifiedName  The REST request would look something like this  GET /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute&#x3D;someValue
   *
   * @param typeName  
   * @param ignoreRelationships  (optional, default to false)
   * @param minExtInfo  (optional, default to false)
   * @return Future(JsonAtlasEntityWithExtInfo)
   */
  def getByUniqueAttributesAsync(typeName: String, ignoreRelationships: Option[Boolean] = Option(false), minExtInfo: Option[Boolean] = Option(false)): Future[JsonAtlasEntityWithExtInfo] = {
      helper.getByUniqueAttributes(typeName, ignoreRelationships, minExtInfo)
  }

  /**
   * Gets the list of classifications for a given entity represented by a guid.
   * Gets the list of classifications for a given entity represented by a guid.
   *
   * @param classificationName  
   * @param guid globally unique identifier for the entity 
   * @return JsonAtlasClassification
   */
  def getClassification(classificationName: String, guid: String): Option[JsonAtlasClassification] = {
    val await = Try(Await.result(getClassificationAsync(classificationName, guid), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Gets the list of classifications for a given entity represented by a guid. asynchronously
   * Gets the list of classifications for a given entity represented by a guid.
   *
   * @param classificationName  
   * @param guid globally unique identifier for the entity 
   * @return Future(JsonAtlasClassification)
   */
  def getClassificationAsync(classificationName: String, guid: String): Future[JsonAtlasClassification] = {
      helper.getClassification(classificationName, guid)
  }

  /**
   * Gets the list of classifications for a given entity represented by a guid.
   * Gets the list of classifications for a given entity represented by a guid.
   *
   * @param guid globally unique identifier for the entity 
   * @return JsonAtlasClassifications
   */
  def getClassifications(guid: String): Option[JsonAtlasClassifications] = {
    val await = Try(Await.result(getClassificationsAsync(guid), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Gets the list of classifications for a given entity represented by a guid. asynchronously
   * Gets the list of classifications for a given entity represented by a guid.
   *
   * @param guid globally unique identifier for the entity 
   * @return Future(JsonAtlasClassifications)
   */
  def getClassificationsAsync(guid: String): Future[JsonAtlasClassifications] = {
      helper.getClassifications(guid)
  }

  /**
   * Bulk API to retrieve list of entities identified by its unique attributes.
   * Bulk API to retrieve list of entities identified by its unique attributes.  In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the following format  typeName&#x3D;&lt;typeName&gt;&amp;attr_1:&lt;attrName&gt;&#x3D;&lt;attrValue&gt;&amp;attr_2:&lt;attrName&gt;&#x3D;&lt;attrValue&gt;&amp;attr_3:&lt;attrName&gt;&#x3D;&lt;attrValue&gt;  NOTE: The attrName should be an unique attribute for the given entity-type  The REST request would look something like this  GET /v2/entity/bulk/uniqueAttribute/type/hive_db?attrs_0:qualifiedName&#x3D;db1@cl1&amp;attrs_2:qualifiedName&#x3D;db2@cl1
   *
   * @param typeName  
   * @param ignoreRelationships  (optional, default to false)
   * @param minExtInfo  (optional, default to false)
   * @return JsonAtlasEntitiesWithExtInfo
   */
  def getEntitiesByUniqueAttributes(typeName: String, ignoreRelationships: Option[Boolean] = Option(false), minExtInfo: Option[Boolean] = Option(false)): Option[JsonAtlasEntitiesWithExtInfo] = {
    val await = Try(Await.result(getEntitiesByUniqueAttributesAsync(typeName, ignoreRelationships, minExtInfo), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Bulk API to retrieve list of entities identified by its unique attributes. asynchronously
   * Bulk API to retrieve list of entities identified by its unique attributes.  In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the following format  typeName&#x3D;&lt;typeName&gt;&amp;attr_1:&lt;attrName&gt;&#x3D;&lt;attrValue&gt;&amp;attr_2:&lt;attrName&gt;&#x3D;&lt;attrValue&gt;&amp;attr_3:&lt;attrName&gt;&#x3D;&lt;attrValue&gt;  NOTE: The attrName should be an unique attribute for the given entity-type  The REST request would look something like this  GET /v2/entity/bulk/uniqueAttribute/type/hive_db?attrs_0:qualifiedName&#x3D;db1@cl1&amp;attrs_2:qualifiedName&#x3D;db2@cl1
   *
   * @param typeName  
   * @param ignoreRelationships  (optional, default to false)
   * @param minExtInfo  (optional, default to false)
   * @return Future(JsonAtlasEntitiesWithExtInfo)
   */
  def getEntitiesByUniqueAttributesAsync(typeName: String, ignoreRelationships: Option[Boolean] = Option(false), minExtInfo: Option[Boolean] = Option(false)): Future[JsonAtlasEntitiesWithExtInfo] = {
      helper.getEntitiesByUniqueAttributes(typeName, ignoreRelationships, minExtInfo)
  }

  /**
   * 
   * 
   *
   * @param tagUpdateStartTime  (optional)
   * @return void
   */
  def getEntityHeaders(tagUpdateStartTime: Option[Long] = None) = {
    val await = Try(Await.result(getEntityHeadersAsync(tagUpdateStartTime), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param tagUpdateStartTime  (optional)
   * @return Future(void)
   */
  def getEntityHeadersAsync(tagUpdateStartTime: Option[Long] = None) = {
      helper.getEntityHeaders(tagUpdateStartTime)
  }

  /**
   * Get entity header given its GUID.
   * Get entity header given its GUID.
   *
   * @param guid GUID for the entity 
   * @return JsonAtlasEntityHeader
   */
  def getHeaderById(guid: String): Option[JsonAtlasEntityHeader] = {
    val await = Try(Await.result(getHeaderByIdAsync(guid), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get entity header given its GUID. asynchronously
   * Get entity header given its GUID.
   *
   * @param guid GUID for the entity 
   * @return Future(JsonAtlasEntityHeader)
   */
  def getHeaderByIdAsync(guid: String): Future[JsonAtlasEntityHeader] = {
      helper.getHeaderById(guid)
  }

  /**
   * Entity Partial Update - Add/Update entity attribute identified by its GUID.
   * Entity Partial Update - Add/Update entity attribute identified by its GUID. Supports only uprimitive attribute type and entity references. does not support updation of complex types like arrays, maps Null updates are not possible
   *
   * @param guid  
   * @param name  (optional)
   * @param body  (optional)
   * @return JsonEntityMutationResponse
   */
  def partialUpdateEntityAttrByGuid(guid: String, name: Option[String] = None, body: Option[Any] = None): Option[JsonEntityMutationResponse] = {
    val await = Try(Await.result(partialUpdateEntityAttrByGuidAsync(guid, name, body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Entity Partial Update - Add/Update entity attribute identified by its GUID. asynchronously
   * Entity Partial Update - Add/Update entity attribute identified by its GUID. Supports only uprimitive attribute type and entity references. does not support updation of complex types like arrays, maps Null updates are not possible
   *
   * @param guid  
   * @param name  (optional)
   * @param body  (optional)
   * @return Future(JsonEntityMutationResponse)
   */
  def partialUpdateEntityAttrByGuidAsync(guid: String, name: Option[String] = None, body: Option[Any] = None): Future[JsonEntityMutationResponse] = {
      helper.partialUpdateEntityAttrByGuid(guid, name, body)
  }

  /**
   * Entity Partial Update - Allows a subset of attributes to be updated on an entity which is identified by its type and unique attribute  eg: Referenceable.
   * Entity Partial Update - Allows a subset of attributes to be updated on an entity which is identified by its type and unique attribute  eg: Referenceable.qualifiedName. Null updates are not possible  In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the following format  attr:&lt;attrName&gt;&#x3D;&lt;attrValue&gt;  NOTE: The attrName and attrValue should be unique across entities, eg. qualifiedName  The REST request would look something like this  PUT /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute&#x3D;someValue
   *
   * @param typeName  
   * @param body  (optional)
   * @return JsonEntityMutationResponse
   */
  def partialUpdateEntityByUniqueAttrs(typeName: String, body: Option[JsonAtlasEntityWithExtInfo] = None): Option[JsonEntityMutationResponse] = {
    val await = Try(Await.result(partialUpdateEntityByUniqueAttrsAsync(typeName, body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Entity Partial Update - Allows a subset of attributes to be updated on an entity which is identified by its type and unique attribute  eg: Referenceable. asynchronously
   * Entity Partial Update - Allows a subset of attributes to be updated on an entity which is identified by its type and unique attribute  eg: Referenceable.qualifiedName. Null updates are not possible  In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the following format  attr:&lt;attrName&gt;&#x3D;&lt;attrValue&gt;  NOTE: The attrName and attrValue should be unique across entities, eg. qualifiedName  The REST request would look something like this  PUT /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute&#x3D;someValue
   *
   * @param typeName  
   * @param body  (optional)
   * @return Future(JsonEntityMutationResponse)
   */
  def partialUpdateEntityByUniqueAttrsAsync(typeName: String, body: Option[JsonAtlasEntityWithExtInfo] = None): Future[JsonEntityMutationResponse] = {
      helper.partialUpdateEntityByUniqueAttrs(typeName, body)
  }

  /**
   * 
   * 
   *
   * @param body  (optional)
   * @return void
   */
  def setClassifications(body: Option[Any] = None) = {
    val await = Try(Await.result(setClassificationsAsync(body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param body  (optional)
   * @return Future(void)
   */
  def setClassificationsAsync(body: Option[Any] = None) = {
      helper.setClassifications(body)
  }

  /**
   * Updates classifications to an existing entity represented by a guid.
   * Updates classifications to an existing entity represented by a guid.
   *
   * @param guid globally unique identifier for the entity 
   * @param body  (optional)
   * @return void
   */
  def updateClassifications(guid: String, body: Option[List[JsonAtlasClassification]] = None) = {
    val await = Try(Await.result(updateClassificationsAsync(guid, body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Updates classifications to an existing entity represented by a guid. asynchronously
   * Updates classifications to an existing entity represented by a guid.
   *
   * @param guid globally unique identifier for the entity 
   * @param body  (optional)
   * @return Future(void)
   */
  def updateClassificationsAsync(guid: String, body: Option[List[JsonAtlasClassification]] = None) = {
      helper.updateClassifications(guid, body)
  }

  /**
   * Updates classification on an entity identified by its type and unique attributes.
   * Updates classification on an entity identified by its type and unique attributes.
   *
   * @param typeName  
   * @param body  (optional)
   * @return void
   */
  def updateClassificationsByUniqueAttribute(typeName: String, body: Option[List[JsonAtlasClassification]] = None) = {
    val await = Try(Await.result(updateClassificationsByUniqueAttributeAsync(typeName, body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Updates classification on an entity identified by its type and unique attributes. asynchronously
   * Updates classification on an entity identified by its type and unique attributes.
   *
   * @param typeName  
   * @param body  (optional)
   * @return Future(void)
   */
  def updateClassificationsByUniqueAttributeAsync(typeName: String, body: Option[List[JsonAtlasClassification]] = None) = {
      helper.updateClassificationsByUniqueAttribute(typeName, body)
  }

}

class EntityRESTApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def addClassification(body: Option[JsonClassificationAssociateRequest] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[Option[JsonClassificationAssociateRequest]]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/v2/entity/bulk/classification"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addClassifications(guid: String,
    body: Option[List[JsonAtlasClassification]] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[Option[List[JsonAtlasClassification]]]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/v2/entity/guid/{guid}/classifications")
      replaceAll("\\{" + "guid" + "\\}", guid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (guid == null) throw new Exception("Missing required parameter 'guid' when calling EntityRESTApi->addClassifications")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addClassificationsByUniqueAttribute(typeName: String,
    body: Option[List[JsonAtlasClassification]] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[Option[List[JsonAtlasClassification]]]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/v2/entity/uniqueAttribute/type/{typeName}/classifications")
      replaceAll("\\{" + "typeName" + "\\}", typeName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (typeName == null) throw new Exception("Missing required parameter 'typeName' when calling EntityRESTApi->addClassificationsByUniqueAttribute")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createOrUpdateEntities(body: Option[JsonAtlasEntitiesWithExtInfo] = None
    )(implicit reader: ClientResponseReader[JsonEntityMutationResponse], writer: RequestWriter[Option[JsonAtlasEntitiesWithExtInfo]]): Future[JsonEntityMutationResponse] = {
    // create path and map variables
    val path = (addFmt("/v2/entity/bulk"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createOrUpdateSingleEntity(body: Option[JsonAtlasEntityWithExtInfo] = None
    )(implicit reader: ClientResponseReader[JsonEntityMutationResponse], writer: RequestWriter[Option[JsonAtlasEntityWithExtInfo]]): Future[JsonEntityMutationResponse] = {
    // create path and map variables
    val path = (addFmt("/v2/entity"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteByGuid(guid: String)(implicit reader: ClientResponseReader[JsonEntityMutationResponse]): Future[JsonEntityMutationResponse] = {
    // create path and map variables
    val path = (addFmt("/v2/entity/guid/{guid}")
      replaceAll("\\{" + "guid" + "\\}", guid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (guid == null) throw new Exception("Missing required parameter 'guid' when calling EntityRESTApi->deleteByGuid")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteByGuids(guid: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[JsonEntityMutationResponse]): Future[JsonEntityMutationResponse] = {
    // create path and map variables
    val path = (addFmt("/v2/entity/bulk"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    guid match {
      case Some(param) => queryParams += "guid" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteByUniqueAttribute(typeName: String)(implicit reader: ClientResponseReader[JsonEntityMutationResponse]): Future[JsonEntityMutationResponse] = {
    // create path and map variables
    val path = (addFmt("/v2/entity/uniqueAttribute/type/{typeName}")
      replaceAll("\\{" + "typeName" + "\\}", typeName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (typeName == null) throw new Exception("Missing required parameter 'typeName' when calling EntityRESTApi->deleteByUniqueAttribute")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteClassification(classificationName: String,
    guid: String,
    associatedEntityGuid: Option[String] = None
    )(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/v2/entity/guid/{guid}/classification/{classificationName}")
      replaceAll("\\{" + "classificationName" + "\\}", classificationName.toString)
      replaceAll("\\{" + "guid" + "\\}", guid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (classificationName == null) throw new Exception("Missing required parameter 'classificationName' when calling EntityRESTApi->deleteClassification")

    if (guid == null) throw new Exception("Missing required parameter 'guid' when calling EntityRESTApi->deleteClassification")

    associatedEntityGuid match {
      case Some(param) => queryParams += "associatedEntityGuid" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteClassificationByUniqueAttribute(classificationName: String,
    typeName: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/v2/entity/uniqueAttribute/type/{typeName}/classification/{classificationName}")
      replaceAll("\\{" + "classificationName" + "\\}", classificationName.toString)
      replaceAll("\\{" + "typeName" + "\\}", typeName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (classificationName == null) throw new Exception("Missing required parameter 'classificationName' when calling EntityRESTApi->deleteClassificationByUniqueAttribute")

    if (typeName == null) throw new Exception("Missing required parameter 'typeName' when calling EntityRESTApi->deleteClassificationByUniqueAttribute")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getAuditEvents(guid: String,
    count: Option[Integer] = Option(100),
    startKey: Option[String] = None
    )(implicit reader: ClientResponseReader[List[JsonEntityAuditEventV2]]): Future[List[JsonEntityAuditEventV2]] = {
    // create path and map variables
    val path = (addFmt("/v2/entity/{guid}/audit")
      replaceAll("\\{" + "guid" + "\\}", guid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (guid == null) throw new Exception("Missing required parameter 'guid' when calling EntityRESTApi->getAuditEvents")

    count match {
      case Some(param) => queryParams += "count" -> param.toString
      case _ => queryParams
    }
    startKey match {
      case Some(param) => queryParams += "startKey" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getByGuids(guid: Option[List[String]] = None,
    ignoreRelationships: Option[Boolean] = Option(false),
    minExtInfo: Option[Boolean] = Option(false)
    )(implicit reader: ClientResponseReader[JsonAtlasEntitiesWithExtInfo]): Future[JsonAtlasEntitiesWithExtInfo] = {
    // create path and map variables
    val path = (addFmt("/v2/entity/bulk"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    guid match {
      case Some(param) => queryParams += "guid" -> param.toString
      case _ => queryParams
    }
    ignoreRelationships match {
      case Some(param) => queryParams += "ignoreRelationships" -> param.toString
      case _ => queryParams
    }
    minExtInfo match {
      case Some(param) => queryParams += "minExtInfo" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getById(guid: String,
    ignoreRelationships: Option[Boolean] = Option(false),
    minExtInfo: Option[Boolean] = Option(false)
    )(implicit reader: ClientResponseReader[JsonAtlasEntityWithExtInfo]): Future[JsonAtlasEntityWithExtInfo] = {
    // create path and map variables
    val path = (addFmt("/v2/entity/guid/{guid}")
      replaceAll("\\{" + "guid" + "\\}", guid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (guid == null) throw new Exception("Missing required parameter 'guid' when calling EntityRESTApi->getById")

    ignoreRelationships match {
      case Some(param) => queryParams += "ignoreRelationships" -> param.toString
      case _ => queryParams
    }
    minExtInfo match {
      case Some(param) => queryParams += "minExtInfo" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getByUniqueAttributes(typeName: String,
    ignoreRelationships: Option[Boolean] = Option(false),
    minExtInfo: Option[Boolean] = Option(false)
    )(implicit reader: ClientResponseReader[JsonAtlasEntityWithExtInfo]): Future[JsonAtlasEntityWithExtInfo] = {
    // create path and map variables
    val path = (addFmt("/v2/entity/uniqueAttribute/type/{typeName}")
      replaceAll("\\{" + "typeName" + "\\}", typeName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (typeName == null) throw new Exception("Missing required parameter 'typeName' when calling EntityRESTApi->getByUniqueAttributes")

    ignoreRelationships match {
      case Some(param) => queryParams += "ignoreRelationships" -> param.toString
      case _ => queryParams
    }
    minExtInfo match {
      case Some(param) => queryParams += "minExtInfo" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getClassification(classificationName: String,
    guid: String)(implicit reader: ClientResponseReader[JsonAtlasClassification]): Future[JsonAtlasClassification] = {
    // create path and map variables
    val path = (addFmt("/v2/entity/guid/{guid}/classification/{classificationName}")
      replaceAll("\\{" + "classificationName" + "\\}", classificationName.toString)
      replaceAll("\\{" + "guid" + "\\}", guid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (classificationName == null) throw new Exception("Missing required parameter 'classificationName' when calling EntityRESTApi->getClassification")

    if (guid == null) throw new Exception("Missing required parameter 'guid' when calling EntityRESTApi->getClassification")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getClassifications(guid: String)(implicit reader: ClientResponseReader[JsonAtlasClassifications]): Future[JsonAtlasClassifications] = {
    // create path and map variables
    val path = (addFmt("/v2/entity/guid/{guid}/classifications")
      replaceAll("\\{" + "guid" + "\\}", guid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (guid == null) throw new Exception("Missing required parameter 'guid' when calling EntityRESTApi->getClassifications")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getEntitiesByUniqueAttributes(typeName: String,
    ignoreRelationships: Option[Boolean] = Option(false),
    minExtInfo: Option[Boolean] = Option(false)
    )(implicit reader: ClientResponseReader[JsonAtlasEntitiesWithExtInfo]): Future[JsonAtlasEntitiesWithExtInfo] = {
    // create path and map variables
    val path = (addFmt("/v2/entity/bulk/uniqueAttribute/type/{typeName}")
      replaceAll("\\{" + "typeName" + "\\}", typeName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (typeName == null) throw new Exception("Missing required parameter 'typeName' when calling EntityRESTApi->getEntitiesByUniqueAttributes")

    ignoreRelationships match {
      case Some(param) => queryParams += "ignoreRelationships" -> param.toString
      case _ => queryParams
    }
    minExtInfo match {
      case Some(param) => queryParams += "minExtInfo" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getEntityHeaders(tagUpdateStartTime: Option[Long] = None
    )(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/v2/entity/bulk/headers"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    tagUpdateStartTime match {
      case Some(param) => queryParams += "tagUpdateStartTime" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getHeaderById(guid: String)(implicit reader: ClientResponseReader[JsonAtlasEntityHeader]): Future[JsonAtlasEntityHeader] = {
    // create path and map variables
    val path = (addFmt("/v2/entity/guid/{guid}/header")
      replaceAll("\\{" + "guid" + "\\}", guid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (guid == null) throw new Exception("Missing required parameter 'guid' when calling EntityRESTApi->getHeaderById")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def partialUpdateEntityAttrByGuid(guid: String,
    name: Option[String] = None,
    body: Option[Any] = None
    )(implicit reader: ClientResponseReader[JsonEntityMutationResponse], writer: RequestWriter[Option[Any]]): Future[JsonEntityMutationResponse] = {
    // create path and map variables
    val path = (addFmt("/v2/entity/guid/{guid}")
      replaceAll("\\{" + "guid" + "\\}", guid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (guid == null) throw new Exception("Missing required parameter 'guid' when calling EntityRESTApi->partialUpdateEntityAttrByGuid")

    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def partialUpdateEntityByUniqueAttrs(typeName: String,
    body: Option[JsonAtlasEntityWithExtInfo] = None
    )(implicit reader: ClientResponseReader[JsonEntityMutationResponse], writer: RequestWriter[Option[JsonAtlasEntityWithExtInfo]]): Future[JsonEntityMutationResponse] = {
    // create path and map variables
    val path = (addFmt("/v2/entity/uniqueAttribute/type/{typeName}")
      replaceAll("\\{" + "typeName" + "\\}", typeName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (typeName == null) throw new Exception("Missing required parameter 'typeName' when calling EntityRESTApi->partialUpdateEntityByUniqueAttrs")


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def setClassifications(body: Option[Any] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[Option[Any]]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/v2/entity/bulk/setClassifications"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateClassifications(guid: String,
    body: Option[List[JsonAtlasClassification]] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[Option[List[JsonAtlasClassification]]]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/v2/entity/guid/{guid}/classifications")
      replaceAll("\\{" + "guid" + "\\}", guid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (guid == null) throw new Exception("Missing required parameter 'guid' when calling EntityRESTApi->updateClassifications")


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateClassificationsByUniqueAttribute(typeName: String,
    body: Option[List[JsonAtlasClassification]] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[Option[List[JsonAtlasClassification]]]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/v2/entity/uniqueAttribute/type/{typeName}/classifications")
      replaceAll("\\{" + "typeName" + "\\}", typeName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (typeName == null) throw new Exception("Missing required parameter 'typeName' when calling EntityRESTApi->updateClassificationsByUniqueAttribute")


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
